# job4j_threads

job4j.ru middle java developer

### 1, 2. Git теория и практика, экзамен.

### 3. Threads

#### 3.1.1. Threads

1. Теория многопоточность, параллелизм и многопоточность.
   a) Java 8, Полное руководство - Герберт Шилдт. Глава 11 (стр. 285)
   b) Библиотека профессионала. Java. Том 1. Основы - Кей Хостманн, Гари Корнелл. Глава 14 (стр. 753)
   c) Head First Java - Кэти Сьерра и Берт Бейтс. Глава 15 (стр. 519)
   d) Философия Java - Брюс Эккель. Глава 21 (стр. 887)

2. Создание и запуск нити [ru.job4j.concurrent.ConcurrentOutput]
   В метод main класса ru.job4j.concurrent.ConcurrentOutput создайте еще один объект Thread. Присвойте имя переменной
   second. В конструкторе нового объекта задайте вывод на консоль имени новой нити. Для этого воспользуйтесь оператором.
   ``` Thread.currentThread().getName(); ```

3. Состояние нити. [ru.job4j.concurrent.ThreadState]
   Поправьте класс ThreadState там образом, чтобы в нем создавалось две нити. Каждая нить должна вывести свое имя на
   консоль.

4. Режим ожидания. [ru.job4j.concurrent.Wget]
   Создайте нить внутри метода main. В теле метода создайте цикл от 0 до 100 %. Через 1 секунду выводите на консоль
   информацию о загрузке. Вывод должен быть с обновлением строки.

5. Прерывание нити [ru.job4j.concurrent.ConsoleProgress]
   Создайте класс ru.job4j.concurrent.ConsoleProgress. Этот класс будет использован для вывода процесса загрузки в
   консоль.
   Этот класс должен реализовывать интерфейс java.lang.Runnable. Внутри метода run нужно добавить цикл с проверкой
   флага. Внутри цикла - сделать задержку в 500 мс. В тело цикла добавьте вывод в консоль.
   "Loading ... |." Символ "палочка" каждые 500мс должен меняться на символы:
   ```var process = new char[] {'-', '\', '|', '/'};```
   Последовательная смена символов создадут динамический эффект загрузки.
6. Прерывание блокированной нити. [ru.job4j.concurrent.ConsoleProgress]
   Если используются методы sleep(), join(), wait() или аналогичные временно блокирующие поток методы, то нужно в блоке
   catch вызвать прерывание. (Thread.currentThread().interrupt();)
7. Приоритеты нитей и нити-демоны (теория).
8. Скачивание файла с ограничением. [ru.job4j.concurrent.Wget]
   Вносим изменения в класс из пункта (4) историю изменений смотрим в git.
   В этом задании нужно написать консольную программу - аналог wget. Программа должна скачивать файл из сети с
   ограничением по скорости скачки.

#### 3.1.2. Общие ресурсы

1. Синхронизация общих ресурсов. [ru.job4j.Cache]
   Исправить ошибку атомарности в коде.
2. Модель памяти Java [ru.job4j.DCLSingleton]
   Код синглтона - double check locking. Исправьте в нем ошибку.
3. Immutable объекты [ru.job4j.linked.Node<T>]
   Сделайте этот класс Immutable.
4. Thread без общих ресурсов [ru.job4j.UserCache]
   Другое решение проблемы многопоточной среды - избавление от общих ресурсов. Как избавиться от общих ресурсов? Можно
   сделать копию общего ресурса. В этом случае каждая нить работает с локальной копией.

#### 3.1.3. Синхронизация ресурсов

1. Visibility. Общий ресурс вне критической секции [ru.job4j.io.ParseFile]
   Поправьте код с ошибками в коде.
    - Избавиться от get set за счет передачи File в конструктор.
    - Ошибки в многопоточности. Сделать класс Immutable. Все поля final.
    - Ошибки в IO. Не закрытые ресурсы. Чтение и запись файла без буфера.
    - Нарушен принцип единой ответственности. Тут нужно сделать два класса.
    - Методы getContent написаны в стиле копипаста. Нужно применить шаблон стратегия. content(Predicate<Character>
      filter)
2. JCIP. Настройка библиотеки [ru.job4j.threads.Count]
   Знакомство с библиотекой jcip, которая помогает отслеживать ошибки в многопоточном окружении.
   _Совет. Старайтесь использовать ее везде, где появляются мониторы._
3. Денежные переводы AccountStorage [ru.job4j.cash.AccountStorage]
   В этом задании нужно сделать блокирующий кеш AccountStorage для модели Account. В этом уроке вам нужно решить
   классическую задачу по переводу денег с одного счета на другой.
   У нас будет многопользовательская среда, а значит нам нужно обеспечить эксклюзивных доступ к хранилищу пользователей.
   Чтобы операции были атомарны, нам нужен один монитор. В этом задании монитором будет объект класса AccountStorage.
    - Реализуйте код в классе AccountStorage. Класс AccountStorage должен работает в многопоточном окружении.
    - Допишите новые тесты на метод transfer.
4. ThreadSafe динамический список  [ru.job4j.synch.SingleLockList]
   В этой задаче Вам нужно создать коллекцию, которая будет корректно работать в многопоточный среде.

#### 3.1.4. Wait, Notify, NotifyAll

0. Управление нитью через wait. [ru.job4j.CountBarrier]
   Разработайте класс, который блокирует выполнение по условию счетчика. Переменная total содержит количество вызовов
   метода count().
   Метод count изменяет состояние программы. Это значит, что внутри метода count нужно вызывать метод notifyAll.
   Нити, которые выполняют метод await, могут начать работу если поле count >= total. Если оно не равно, то нужно
   перевести нить в состояние wait.
1. Реализовать шаблон Producer Consumer. [ru.job4j.collections.SimpleBlockingQueue]
   Для этого вам необходимо реализовать собственную версию bounded blocking queue. Это блокирующая очередь,
   ограниченная по размеру. В данном шаблоне Producer помещает данные в очередь, а Consumer извлекает данные из
   очереди.
2. Обеспечить остановку потребителя. [ru.job4j.buffer.ParallelSearch]
   В этом задании нужно разработать механизм остановки потребителя, когда производитель закончил свою работу.
   Изменить код, так, что бы потребитель завершал свою работу. Код нужно изменить в методе main.

#### 3.1.5. Non Blocking Algoritm

0. CAS - операции [ru.job4j.CASCount, ru.job4j.CASCountAtomicReference]
   AtomicReference, AtomicInteger
   Операции write и read по отдельности атомарны. volatile обеспечивает правильную публикацию изменений.
   Но во многих случаях нам нужны действия check-then-act. Чтобы этого добиться, нужно делать синхронизацию.
   Синхронизация блокирует выполнение нитей, то есть программа из многопоточной превращается в однопоточную. 